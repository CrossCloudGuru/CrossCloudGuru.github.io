---
title: "[3/3] Arch Linux in VMware Workstation - The scripts in detail"
date: 2019-12-24T15:15:00-04:00
categories:
  - blog
tags:
  - linux
  - vmware
---

This article is part of the series Arch Linux in a VMware Workstation.

In this third article of the series I will explain part by part the script I have created so you get an understanding how/why I did the things I did. Afterwards you can utilize and modify the script as you see fit.

I assume you have worked through the articles: Article 1: Setup the virtual machine and Article 2: Prepare and execute the scripts and therefore have access to the scripts already.

Now lets get into the details! For the impatient, the link to the full script is at the bottom of this post...

### ArchInstallation.sh - Header

```bash
#!/usr/bin/env bash ################################################################################ 
# Filename: ArchInstallation.sh 
# Date Created: 21-dec-19 
# Date last update: 21-dec-19 
# Author: Marco Tijbout 
# 
# Version 0.1 
# 
# Enhancement ideas: 
# - 
# 
# Version history: 
# 0.1 Marco Tijbout: 
# Initial release of the script. 
################################################################################
```

The header area is for me where I do my housekeeping. An area where I can note what has changed, what my plans are that become future changes/updates.

Every script used should have a line to tell the system what engine / language to use:

```bash
#!/usr/bin/env bash
```

Usually you see #!/bin/bash but I have learned to use my format that makes the system look for bash itself instead of assuming its location. So I use `#!/usr/bin/env bash`

When reading the installation guide on the ArchWiki you will notice some sections like pre-installation and installation. I tried to group the items to the sections.

### The Pre-Installation section

```bash
################################################################################
## PRE-INSTALLATION
################################################################################

# Configure to use NTP (preferably already before the script is run):
echo -e "\n * Configure system to use NTP ...\n"
timedatectl set-ntp true

# Check if the installation disk of 40GB is found:
echo -e "\n * Probe the installation disk ...\n"
DISK_NAME=$(fdisk -l | grep "GiB" | awk -F ':' '{print $1}' | awk '{print $2}')
echo -e "Disk: Recognized as $DISK_NAME"

DISK_SIZE_GB=$(fdisk -l | grep "GiB" | awk '{print $3}')
echo -e "Disk: Size in GB: $DISK_SIZE_GB"

# Create a partition layout file for a 40GB disk:
echo -e "\n * Create partition layout file ...\n"
source diskSectorCalculator.sh $DISK_SIZE_GB

# Partition the disk based on the layout file:
echo -e "\n * Partition the disk ...\n"
sfdisk --force $DISK_NAME < layout.sfdisk

# Formatting the freshly created partitions:
echo -e "\n * Formatting the partitions on the disk ...\n"
mkfs.fat -F32 ${DISK_NAME}1
mkfs.ext4 -F ${DISK_NAME}2

# Prep and enable the swap partition:
echo -e "\n * Enable swap partition ...\n"
mkswap ${DISK_NAME}3
swapon ${DISK_NAME}3

# Mounting the partitions:
echo -e "\n * Mounting of the partitions ...\n"
mount ${DISK_NAME}2 /mnt
mkdir -p /mnt/boot
mount ${DISK_NAME}1 /mnt/boot
```

If not already done, synchronize the time with NTP:

```bash
# Configure to use NTP (preferably already before the script is run):
echo -e "\n * Configure system to use NTP ...\n"
timedatectl set-ntp true
```

During boot the Live system identified the disk. For creating a partition scheme we need to know the name it was assigned:

```bash
# Check if the installation disk of 40GB is found:
echo -e "\n * Probe the installation disk ...\n"
DISK_NAME=$(fdisk -l | grep "GiB" | awk -F ':' '{print $1}' | awk '{print $2}')
echo -e "Disk: Recognized as $DISK_NAME"
```

The script assumes that only one disk is attached to the virtual machine and is at least a couple of GB in size.

What happens here is:

* We use information provided by the command `fdisk -l`
* grep GiB filters out the line of information we are looking for
* `awk -F ':' '{print $1}'` We need to cut the required information separating the : from the information we need and use the FIRST part
* `awk '{print $2}'` From this 'first' part we need the second value
* To store it in a variable for later usage we need to wrap it in `$()`

As this script will create a partition layout automatically based on size, we need to figure out the size of the disk:

```bash
# Probe the size of the disk:
DISK_SIZE_GB=$(fdisk -l | grep "GiB" | awk '{print $3}')
echo -e "Disk: Size in GB: $DISK_SIZE_GB"
```

What happens here is:

* We use information provided by the command `fdisk -l`
* grep GiB filters out the line of information we are looking for
* `awk '{print $3}'` From this first part we need the third value

With the information we have collected so far we can create a configuration file that is used to create partition later:

```bash
# Create a partition layout file for a 40GB disk:
echo -e "\n * Create partition layout file ...\n"
source diskSectorCalculator.sh $DISK_SIZE_GB
```

What happens here is:

* `sfdisk` is the tool used to create the partitions
* `--force` tells `sfdisk` to override and answer any objections with YES
* `< layout.sfdisk` reads the content of `layout.sfdisk` as input to the command. Basically applying a template

After the partitions are created, they need to be formatted and the swap partition enabled:

```bash
# Formatting the freshly created partitions:
echo -e "\n * Formatting the partitions on the disk ...\n"
mkfs.fat -F32 ${DISK_NAME}1
mkfs.ext4 -F ${DISK_NAME}2
```

What happens here is:

* `mkfs.fat -F32 ${DISK_NAME}1`
    * `mkfs` is the command to format a partition
    * `.fat` and `-F32` specifies it to be of type FAT32
    * `${DISK_NAME}1` specifies the name of the disk identified by the live system like `/dev/sda` and the addition `1` specifies the first partition
* `mkfs.ext4 -F ${DISK_NAME}2`
    * The same approach as the previous one where .ext4 specifies it to format as a Linux partition
    * `${DISK_NAME}2` specifies the name of the disk identified by the live system like `/dev/sda` and the addition `2` specifies the second partition

```bash
# Prep and enable the swap partition:
echo -e "\n * Enable swap partition ...\n"
mkswap ${DISK_NAME}3
swapon ${DISK_NAME}3
```

What happens here is:

* `mkswap` is the command to create a swap location for the system (kernel)
* `${DISK_NAME}3` specifies the name of the disk identified by the live system like `/dev/sda` and the addition `3` specifies the third partition
* `swapon` is the command to enable the swap location

Now that all partitions are created and formatted we need to mount them to use them to get some content on them:

```bash
# Mounting the partitions:
echo -e "\n * Mounting of the partitions ...\n"
mount ${DISK_NAME}2 /mnt
mkdir -p /mnt/boot
mount ${DISK_NAME}1 /mnt/boot
```

What happens here is:

* `mount` is the command to mount a partition where
    * `${DISK_NAME}2` tells it to use the second partition `/dev/sda2` and
    * `/mnt` specifies the mount point, e.g. the folder to access the partition from
* `mkdir` is the command to create a new directory where
    * `-p` specifies to create the full path of directories. (Is in this case obsolete as `/mnt` already exist. Good habits die hard)
    * `/mnt/boot` specifies the folder boot to be created under `/mnt`







